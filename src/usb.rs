use std::mem;
use libusb::Error;

#[derive(Debug,PartialEq)]
#[repr(C, packed)]
struct PacketHead {
    id: u64,
    urb_type: u8,
    transfer_type: u8,
    endpoint_direction: u8,
    device: u8,
    bus_id: u16,
    setup_request: u8,
    data_present: u8,
    sec: u64,
    usec: u32,
    status: u32,
    length: u32,
    data_length: u32,
    bm_request_type: u8,
    b_request: u8,
    descriptor_index: u8,
    descriptor_type: u8,
    language_id: u16,
    w_length: u16,
    interval: u32,
    start_frame: u32,
    transfer_flags: u32,
    num_iso_desc: u32,
}

#[derive(Debug,PartialEq)]
pub struct Packet<'a> {
    head: &'a PacketHead,
    data: &'a [u8],
}

#[allow(unused)]
impl<'a> Packet<'a> {
    pub fn from_bytes(bytes: &'a [u8]) -> Option<Packet> {
        if bytes.len() < 64 {
            return None;
        }
        let head = unsafe { mem::transmute(bytes[..64].as_ptr()) };
        Some(Packet { head: head, data: &bytes[64..] })
    }

    pub fn get_id(&self) -> u64 {
        self.head.id
    }
    pub fn get_urb_type(&self) -> UrbType {
        UrbType::from(self.head.urb_type)
    }
    pub fn get_transfer_type(&self) -> TransferType {
        TransferType::from(self.head.transfer_type)
    }
    pub fn get_direction(&self) -> Direction {
        Direction::from((self.head.endpoint_direction & 0x80) == 0x80)
    }
    pub fn get_endpoint(&self) -> u8 {
        self.head.endpoint_direction & 0x7f
    }
    pub fn get_endpoint_direction(&self) -> u8 {
        self.head.endpoint_direction
    }
    pub fn get_device(&self) -> u8 {
        self.head.device
    }
    pub fn get_bus_id(&self) -> u16 {
        self.head.bus_id
    }
    pub fn get_setup_request(&self) -> u8 {
        self.head.setup_request
    }
    pub fn is_data_present(&self) -> bool {
        // yep, you read correctly!
        // if data is present, the value is actually 0x00
        self.head.data_present == 0x00
    }
    pub fn get_sec(&self) -> u64 {
        self.head.sec
    }
    pub fn get_usec(&self) -> u32 {
        self.head.usec
    }
    pub fn get_status(&self) -> UrbStatus {
        UrbStatus::from(self.head.status)
    }
    pub fn get_length(&self) -> u32 {
        self.head.length
    }
    pub fn get_data_length(&self) -> u32 {
        self.head.data_length
    }
    pub fn get_bm_request_type(&self) -> u8 {
        self.head.bm_request_type
    }
    pub fn get_b_request(&self) -> u8 {
        self.head.b_request
    }
    pub fn get_descriptor_index(&self) -> u8 {
        self.head.descriptor_index
    }
    pub fn get_descriptor_type(&self) -> u8 {
        self.head.descriptor_type
    }
    pub fn get_value(&self) -> u16 {
        (self.head.descriptor_type as u16) << 8 | self.head.descriptor_index as u16
    }
    pub fn get_language_id(&self) -> u16 {
        self.head.language_id
    }
    pub fn get_w_length(&self) -> u16 {
        self.head.w_length
    }
    pub fn get_interval(&self) -> u32 {
        self.head.interval
    }
    pub fn get_start_frame(&self) -> u32 {
        self.head.start_frame
    }
    pub fn get_transfer_flags(&self) -> u32 {
        self.head.transfer_flags
    }
    pub fn get_num_iso_desc(&self) -> u32 {
        self.head.num_iso_desc
    }
    pub fn get_data(&self) -> &[u8] {
        self.data
    }

    /// Compares this packet with another packet, ignoring autogenerated
    /// and session based headers
    pub fn same(&self, other: &Self) -> bool {
        self.head.urb_type == other.head.urb_type
            && self.head.transfer_type == other.head.transfer_type
            && self.head.endpoint_direction == other.head.endpoint_direction
            && self.head.setup_request == other.head.setup_request
            && self.head.data_present == other.head.data_present
            && self.head.status == other.head.status
            && self.head.length == other.head.length
            && self.head.data_length == other.head.data_length
            && self.head.bm_request_type == other.head.bm_request_type
            && self.head.b_request == other.head.b_request
            && self.head.descriptor_index == other.head.descriptor_index
            && self.head.descriptor_type == other.head.descriptor_type
            && self.head.language_id == other.head.language_id
            && self.head.w_length == other.head.w_length
            && self.head.transfer_flags == other.head.transfer_flags
            && self.head.num_iso_desc == other.head.num_iso_desc
            && self.data == other.data
    }
}

#[derive(Debug, PartialEq)]
pub enum UrbType {
    Submit, Complete
}

impl From<u8> for UrbType {
    fn from(byte: u8) -> Self {
        return match byte {
            0x43u8 => UrbType::Complete,
            0x53u8 => UrbType::Submit,
            // TODO: std::convert::From must not fail
            // greetings from https://github.com/rust-lang/rfcs/pull/1542
            _ => panic!("Unknown UrbType {}", byte),
        }
    }
}

#[allow(unused)]
#[derive(Debug, PartialEq)]
pub enum TransferType {
    Control, Isochronous, Bulk, Interrupt
}

impl From<u8> for TransferType {
    fn from(byte: u8) -> Self {
        return match byte {
            0x01 => TransferType::Interrupt,
            0x02 => TransferType::Control,
            // TODO: std::convert::From must not fail
            // greetings from https://github.com/rust-lang/rfcs/pull/1542
            _ => panic!("Unknown TransferType {}", byte),
        }
    }
}

#[derive(Debug, PartialEq)]
pub enum Direction {
    In, Out
}

impl From<bool> for Direction {
    fn from(b: bool) -> Self {
        return match b {
            true => Direction::In,
            false => Direction::Out
        }
    }
}

#[derive(Debug, PartialEq)]
pub enum UrbStatus {
    Success,
    InProgress,
    Pipe
}

impl From<u32> for UrbStatus {
    fn from(i: u32) -> Self {
        return match i {
            0x00000000 => UrbStatus::Success,
            0xffffffe0 => UrbStatus::Pipe,
            0xffffff8d => UrbStatus::InProgress,
            // TODO: std::convert::From must not fail
            // greetings from https://github.com/rust-lang/rfcs/pull/1542
            _ => panic!("Unkwnown UrbStatus {}", i)
        }
    }
}

impl PartialEq<Error> for UrbStatus {
    fn eq(&self, err: &Error) -> bool {
        match err {
            &Error::Pipe => *self == UrbStatus::Pipe,
            &Error::Io => false,
            _ => panic!("Unknown UrbStatus {}", err)
        }
    }

    fn ne(&self, err: &Error) -> bool {
        ! (self == err)
    }
}

